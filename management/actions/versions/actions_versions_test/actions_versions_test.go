// Code generated by Fern. DO NOT EDIT.

package actions_versions_test

import (
	"bytes"
	context "context"
	"encoding/json"
	http "net/http"
	os "os"
	testing "testing"

	management "github.com/auth0/go-auth0/v2/management"
	client "github.com/auth0/go-auth0/v2/management/client"
	option "github.com/auth0/go-auth0/v2/management/option"
	require "github.com/stretchr/testify/require"
)

// WireMock configuration - expects WireMock to be running via docker compose
var (
	WireMockBaseURL = getWireMockBaseURL()
)

func getWireMockBaseURL() string {
	if url := os.Getenv("WIREMOCK_URL"); url != "" {
		return url
	}
	return "http://localhost:8080"
}

// setupWireMockStub creates a stub via WireMock's HTTP API
func setupWireMockStub(t *testing.T, stub map[string]interface{}) {
	t.Helper()

	body, err := json.Marshal(stub)
	require.NoError(t, err)

	resp, err := http.Post(WireMockBaseURL+"/__admin/mappings", "application/json", bytes.NewReader(body))
	require.NoError(t, err)
	defer resp.Body.Close()
	require.Equal(t, http.StatusCreated, resp.StatusCode, "Failed to create WireMock stub")
}

// resetWireMock clears all stubs
func resetWireMock(t *testing.T) {
	t.Helper()

	req, err := http.NewRequest(http.MethodDelete, WireMockBaseURL+"/__admin/mappings", nil)
	require.NoError(t, err)

	resp, err := http.DefaultClient.Do(req)
	require.NoError(t, err)
	defer resp.Body.Close()
}

func TestActionsVersionsListWithWireMock(
	t *testing.T,
) {
	defer resetWireMock(t)

	stub := map[string]interface{}{
		"request": map[string]interface{}{
			"method":         "GET",
			"urlPathPattern": "/actions/actions/[^/]+/versions",
		},
		"response": map[string]interface{}{
			"status": http.StatusOK,
			"headers": map[string]string{
				"Content-Type": "application/json",
			},
			"jsonBody": map[string]interface{}{"total": 1.1, "page": 1.1, "per_page": 1.1, "versions": []interface{}{map[string]interface{}{"id": "id", "action_id": "action_id", "code": "code", "dependencies": []interface{}{map[string]interface{}{}}, "deployed": true, "runtime": "runtime", "secrets": []interface{}{map[string]interface{}{}}, "status": "pending", "number": 1.1, "errors": []interface{}{map[string]interface{}{}}, "built_at": "2024-01-15T09:30:00Z", "created_at": "2024-01-15T09:30:00Z", "updated_at": "2024-01-15T09:30:00Z", "supported_triggers": []interface{}{map[string]interface{}{"id": "id"}}}}},
		},
	}
	setupWireMockStub(t, stub)

	c := client.NewWithOptions(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &management.ListActionVersionsRequestParameters{
		Page: management.Int(
			1,
		),
		PerPage: management.Int(
			1,
		),
	}
	_, invocationErr := c.Actions.Versions.List(
		context.TODO(),
		"actionId",
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
}

func TestActionsVersionsGetWithWireMock(
	t *testing.T,
) {
	defer resetWireMock(t)

	stub := map[string]interface{}{
		"request": map[string]interface{}{
			"method":         "GET",
			"urlPathPattern": "/actions/actions/[^/]+/versions/[^/]+",
		},
		"response": map[string]interface{}{
			"status": http.StatusOK,
			"headers": map[string]string{
				"Content-Type": "application/json",
			},
			"jsonBody": map[string]interface{}{"id": "id", "action_id": "action_id", "code": "code", "dependencies": []interface{}{map[string]interface{}{"name": "name", "version": "version", "registry_url": "registry_url"}}, "deployed": true, "runtime": "runtime", "secrets": []interface{}{map[string]interface{}{"name": "name", "updated_at": "2024-01-15T09:30:00Z"}}, "status": "pending", "number": 1.1, "errors": []interface{}{map[string]interface{}{"id": "id", "msg": "msg", "url": "url"}}, "action": map[string]interface{}{"id": "id", "name": "name", "supported_triggers": []interface{}{map[string]interface{}{"id": "id"}}, "all_changes_deployed": true, "created_at": "2024-01-15T09:30:00Z", "updated_at": "2024-01-15T09:30:00Z"}, "built_at": "2024-01-15T09:30:00Z", "created_at": "2024-01-15T09:30:00Z", "updated_at": "2024-01-15T09:30:00Z", "supported_triggers": []interface{}{map[string]interface{}{"id": "id", "version": "version", "status": "status", "runtimes": []interface{}{"runtimes"}, "default_runtime": "default_runtime", "compatible_triggers": []interface{}{map[string]interface{}{"id": "id", "version": "version"}}, "binding_policy": "trigger-bound"}}},
		},
	}
	setupWireMockStub(t, stub)

	c := client.NewWithOptions(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	_, invocationErr := c.Actions.Versions.Get(
		context.TODO(),
		"actionId",
		"id",
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
}

func TestActionsVersionsDeployWithWireMock(
	t *testing.T,
) {
	defer resetWireMock(t)

	stub := map[string]interface{}{
		"request": map[string]interface{}{
			"method":         "POST",
			"urlPathPattern": "/actions/actions/[^/]+/versions/[^/]+/deploy",
		},
		"response": map[string]interface{}{
			"status": http.StatusOK,
			"headers": map[string]string{
				"Content-Type": "application/json",
			},
			"jsonBody": map[string]interface{}{"id": "id", "action_id": "action_id", "code": "code", "dependencies": []interface{}{map[string]interface{}{"name": "name", "version": "version", "registry_url": "registry_url"}}, "deployed": true, "runtime": "runtime", "secrets": []interface{}{map[string]interface{}{"name": "name", "updated_at": "2024-01-15T09:30:00Z"}}, "status": "pending", "number": 1.1, "errors": []interface{}{map[string]interface{}{"id": "id", "msg": "msg", "url": "url"}}, "action": map[string]interface{}{"id": "id", "name": "name", "supported_triggers": []interface{}{map[string]interface{}{"id": "id"}}, "all_changes_deployed": true, "created_at": "2024-01-15T09:30:00Z", "updated_at": "2024-01-15T09:30:00Z"}, "built_at": "2024-01-15T09:30:00Z", "created_at": "2024-01-15T09:30:00Z", "updated_at": "2024-01-15T09:30:00Z", "supported_triggers": []interface{}{map[string]interface{}{"id": "id", "version": "version", "status": "status", "runtimes": []interface{}{"runtimes"}, "default_runtime": "default_runtime", "compatible_triggers": []interface{}{map[string]interface{}{"id": "id", "version": "version"}}, "binding_policy": "trigger-bound"}}},
		},
	}
	setupWireMockStub(t, stub)

	c := client.NewWithOptions(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &management.DeployActionVersionRequestBodyParams{}
	_, invocationErr := c.Actions.Versions.Deploy(
		context.TODO(),
		"actionId",
		"id",
		&request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
}
